use Lidgren.Network

class State is abstract
	# ID -> Entity mapping
	pro entities from var as IDictionary<of int, Entity>

	cue init is protected
		base.init
		.entities = Dictionary<of int, Entity>()
	
	def addEntity(e as Entity)
		.entities.add(e.id, e)
	
	def moveEntity(id as int, src as Point, dest as Point)
		e as Entity?
		if .entities.tryGetValue(id, out e)
			e.pos = dest

class ServerState inherits State
	# IDs are positive integers. An ID of 0 represents "no ID."
	# Thread-unsafe.
	shared
		var _idCounter as int = 0
	def getNewId as int
		_idCounter += 1
		return _idCounter
	var _server as NetServer

	cue init(server as NetServer)
		base.init
		_server = server

	def addEntity(e as Entity)
		if e.id == 0
			e.id = .getNewId
		base.addEntity(e)
		msg = Message.writeToWire(AddMessage(e), _server)
		_server.sendMessage(msg, _server.connections, NetDeliveryMethod.ReliableOrdered, 0)
	
	def moveEntity(id as int, src as Point, dest as Point) is override
		base.moveEntity(id, src, dest)
		msg = Message.writeToWire(MoveMessage(id, src, dest), _server)
		_server.sendMessage(msg, _server.connections, NetDeliveryMethod.ReliableOrdered, 0)

