@ref "bin/Lidgren.Network.dll"
@ref "bin/IronPython.dll"
@ref "bin/Microsoft.Scripting.dll"
@ref "bin/Microsoft.Scripting.Core.dll"

use Lidgren.Network
use IronPython
use System.Security
use System.Security.Policy
use System.Security.Permissions

class SherlockServer
	def main
		config = NetPeerConfiguration("MyExampleName")
		config.port = 14242
		server = NetServer(config)
		server.start
		state = ServerState(server)

		setup = AppDomainSetup()
		setup.applicationBase = AppDomain.currentDomain.baseDirectory
		setup.applicationName = "Testing"

		evidence = Evidence()
		evidence.addHost(Zone(SecurityZone.Internet))

		perms = PermissionSet(PermissionState.None)
		perms.addPermission(SecurityPermission(SecurityPermissionFlag.Execution))
		perms.addPermission(FileIOPermission(FileIOPermissionAccess.Read, "C:/Users/me/code/sherlock/scripts"))

		sandbox = AppDomain.createDomain("Sandbox", evidence, setup, perms)

		engine = IronPython.Hosting.Python.createEngine(sandbox)
		scope = engine.createScope
		
		scriptSource = engine.createScriptSourceFromFile('scripts/base.py')
		scriptSource.execute(scope)
		print "OK"
		s = engine.createScriptSourceFromString("Item().poop()")
		s.execute(scope)
		s.execute(scope)

		while true
			msg = server.readMessage
			if not msg
				continue
			branch msg.messageType
				on NetIncomingMessageType.VerboseDebugMessage or NetIncomingMessageType.DebugMessage _
						or NetIncomingMessageType.WarningMessage or NetIncomingMessageType.ErrorMessage
					print msg.readString
				on NetIncomingMessageType.StatusChanged
					status = msg.readByte
					reason = msg.readString
					print '[msg.senderConnection] status: [status] ([reason])'
				on NetIncomingMessageType.Data
					m = Message.readRequestFromWire(msg to !)
					m.execute(msg.senderConnection to !, state)
			server.recycle(msg)

